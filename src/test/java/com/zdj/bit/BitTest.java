package com.zdj.bit;

import org.junit.Test;

/**
 * @author zhangdj
 * @date 2020/11/27
 * 使用补码进行运算
 * 正数的原码、反码、补码都相同
 * 负数的补码时反码+1
 * 无符号右移高位补0 有符号右移高位补符号位
 *
 */
public class BitTest {

    /**
     * ｜同为０时为０，否则为１
     */
    @Test
    public void t11271640() {
        System.out.println(2 | 3);
    }


    /**
     * ^异或运算 相同为0 不同为1
     * <p>
     * 2 =======>0010
     * <p>
     * 3 =======>0011
     */
    @Test
    public void t1() {
        System.out.println(2 ^ 3);
    }

    /**
     * &与运算 只要有一个为0，就为0
     */
    @Test
    public void t2() {
        System.out.println(2 & 3);
    }

    /**
     * <<(向左位移) 针对二进制，转换成二进制后向左移动3位，后面用0补齐
     * <p>
     * 2 =======>0010
     * <p>
     * 3 =======>0011
     */
    @Test
    public void t3() {
        System.out.println("2<<3运算的结果是 :" + (2 << 3));
    }


    /**
     * >>(向右位移) 针对二进制，转换成二进制后向右移动3位，
     */
    @Test
    public void t4() {
        System.out.println("2>>3运算的结果是 :" + (2 >> 3));
    }


    /**
     * >>>(无符号右移)  无符号右移，忽略符号位，空位都以0补齐
     *
     * 10进制转二进制的时候，因为二进制数一般分8位、 16位、32位以及64位 表示一个十进制数，所以在转换过程中，最高位会补零。
     *
     * 在计算机中负数采用二进制的补码表示，10进制转为二进制得到的是源码，将源码按位取反得到的是反码，反码加1得到补码
     *
     * 二进制的最高位是符号位，0表示正，1表示负。
     *
     * >>>与>>唯一的不同是它无论原来的最左边是什么数，统统都用0填充。
     * ——比如，byte是8位的，-1表示为byte型是11111111(补码表示法）
     * b>>>4就是无符号右移4位，即00001111，这样结果就是15。
     *
     * 正数做>>>运算的时候和>>是一样的。区别在于负数运算
     */
    @Test
    public void t5() {
        System.out.println("16>>2运算的结果是 :"+((16)>>2));

        System.out.println("-16>>2运算的结果是 :"+((-16)>>2));

        System.out.println("16>>>2运算的结果是 :"+((16)>>>2));

        System.out.println("-16>>>2运算的结果是 :"+((-16)>>>2));

        System.out.println("-2>>>1运算的结果是 :"+((-2)>>>1));
    }

    @Test
    public void t6() {
        System.out.println(-10 >> 1);
        System.out.println(-10 >> 2);
    }
}
